### Абстракция данных

Это концепция, согласно которой объект можно описать только теми характеристиками, которых достаточно для точного предоставления его в данной системе, при этом их вполне достаточно чтобы решить с достаточной точностью поставленную задачу.

### Композиция, агрегация, ассоциация

__Композиция__ - отношение _"содержит как часть"_. Это отношение в сложном объекте, состоящем из более простых частей.

* Агрегация - Когда _А_ содержит _B_ внутри себя таким образом, что извне мы видим только _А_. Мы видим _целое_, не представляя его _части_. (Два блока, соединененных линией с ромбом).

* Ассоциация - если мы видим и разделяем и _А_, и _В_. Видно и целое, и его части. Пример ассоциации: ноутбук, к которому подключена мышь. Ассоциация используется, когда одному объекту нужно, чтобы другой объект оказал ему услугу.

__Наследование__ - отношение _"является"_.

-------------
### Cohesion & coupling

Cohesion = сцепление, coupling = связанность.

_Сцепление_ относится к тому, что может делать класс / модуль. _Слабое сцепление_ означает, что класс делает большое разнообразие вещей - он не сфокусирован на основном назначении. Обратно - _сильное сцепление_.

Пример слабого сцепления:

| Staff |
|---|
| checkEmail() |
| sendEmail() |
| printLetter() |

Пример сильного сцепления:

| Staff |
|---|
| -salary |
| -emailAddr |
| setSalary()  |
| setEmailAddr() |
| getSalary()  |
| getEmailAddr() |

_Связанность_ - насколько связаны или зависимы 2 (или больше) класса или модуля. _Слабая связанность_ - существенные изменения в коде одного класса не влияют на код второго класса. _Сильная связанность_ - наоборот, заставляет переделывать всю систему.

_Принцип проектирования_: делайте систему с __сильным сцеплением и слабой связанностью__.

---------------------
### Архитектура сложности

* __Стабильные сложные системы обычно представлены в форме иерархии, где любая система состоит из более простых подсистем, каждая из которых тоже состоит из более простых подсистем__.

* __Стабильные сложные системы почти не поддаются декомпозиции__ - это означает, что вы можете идентифицировать части, образующие систему, и отличить взаимодействия между частями и внутри частей. В стабильных системах меньше связей между их частями, чем внутри их частей. Таким образом, модульная стереосистема с простыми связями между звуковыми колонками, проигрывателем и усилителем по своей природе более стабильна, чем интегрированная система, декомпозиция которой не является легкой.

* __Стабильные сложные системы почти всегда состоят из подсистем лишь нескольких разных типов, упорядоченных в разных комбинациях__ - эти подсистемы, в свою очередь, обычно состоят из частей лишь нескольких разных типов.

* __Стабильные сложные системы почти всегда развиваются из простых рабочих систем__ - вместо того, чтобы создавать новую систему с нуля, то есть изобретать 
велосипед, в качестве ее основы следует использовать проверенные конструкции, которые ей предшествуют.

Допустим, некоторая стереосистема является полностью интегрированной и не разделенной на образующие ее компоненты (то есть представляет собой систему в виде одного большого черного ящика). Что бы было, если бы CD-плеер сломался и стал непригодным к использованию? Вам пришлось бы нести в ремонт всю систему целиком. Это оказалось бы сложнее и дороже, кроме того, вы не смогли бы пользоваться другими компонентами.

---

## SOLID

### S - Single responsibility

### O - Open-closed principle

### L - Liskov substitution

_Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом_. 

Понятие замещения — если S является подтипом T, тогда объекты типа T в программе могут быть замещены объектами типа S без каких-либо изменений желательных свойств этой программы (например, корректности).

Более простыми словами можно сказать, что поведение наследуемых классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.

__Пример__: пусть есть базовый класс `Rectangle` (прямоугольник) и класс `Square` (квадрат). Если класс квадрата сделать производным от первого, то это будет нарушением принципа замещения Лисков, например, следующий код будет работать ожидаемым образом для объектов прямоугольника, но не для квадратов:

```csharp
class Example {
    public void Process(Rectangle rect) {
        rect.Width = 100;
        rect.Height = 2 * rect.Width;
        Debug.Assert(rect.Height == 2 * rect.Width);
    }
}
```


### I - Interface segregation

__Клиенты должны не должны зависеть от интерфейсов, которые они не используют.__

Например, пусть есть широкий интерфейс `IFatMaker`. Тогда по этому принципу его нужно разбить на интерфейсы `IThinnerMaker` и `IOtherThinnerMaker`. 

### D - Dependency inversion

__Объекты высокого уровня не должны заниматься проблемами низкоуровневых реализаций__.

_High level objects should not depend on low level implementations._

Пример: метод, считывающий байты из потока и записывающий их в некоторый буфер

```java
void Copy() {
    Byte byte;
    while(byte = ReadFromStream())
        WriteToBuffer(byte);
}
```

Стоит переделать в 

```java
void Copy(IReader reader, IWriter writer) {
    Byte byte;
    while(byte = reader.Read())
        writer.Write(byte);
}
```

Здесь появляется понятие  __Внедрения Зависимостей__ (__Dependency Inversion__). Есть специальные фреймворки для внедрения зависимостей - например, Dagger2 или Toothpick для Android.

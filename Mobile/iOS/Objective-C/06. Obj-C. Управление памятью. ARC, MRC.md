# Objective-C. Управление памятью.

В Objective-C есть конвенции для выделения памяти под объект в куче. Эти конвенции нужны для корректного освобождения этой памяти механизмом ARC.

MRC: каждый объект имеет при себе счетчик ссылок.

При вызове `release` счетчик ссылок уменьшается на 1. Если он равен 0, то память под объект сразу очищается.

Понятие __владения__ объектом: один объект порождает другой с использованием `alloc`, `new`, `copy` и при этом счетчик ссылок увеличивается на 1. Чтобы освободить память, ему нужно послать сообщение `release` (в ручном режиме MRC). Создает владелец, освобождает - тоже владелец.

`NSObject#retainCount` - счетчик ссылок (не потокобезопасен).

Утечки памяти может показать инструмент профайлер.

---

### Auto release pool

Он связан с классом `NSRunLoop`, который используется для обработки системных событий, тачей и т.д. Это event loop, он содержит логику цикла для событий, благодаря которому программа также не покидает метод main.

auto release - это отложенный вызов  `release`.

Представим структуру в виде массива ("пул"), в которую добавляются указатели через сообщение `autorelease`:

```objectivec
return [arr autorelease];
```

здесь происходит добавление указателя в глобальный auto release pool.

На каждой итерации цикла event loop `NSRunLoop` посылает всем объектам сообщение `release` и они освобождаются.

---

При присвоении указателя счетчик ссылок увеличивается на 1. Может стать равен 2, 3 и т.д., а должен быть равен 1.

```objectivec
NSArray *someArr = [self workers];
```

Счетчик ссылок = 2, а дб = 1.

Если присвоить это в __strong__-свойство, то счетчик +=1 и опять memory leak.

```objectivec 
someStrongProp = [self workers];
```

В методе `dealloc` мы можем послать сообщение объекту `[self workers]` в iVar, но счетчик будет = 1. Утечка все равно будет.

Поэтому его надо добавить в auto release pool. Тогда утечки не будет.

При `[pool drain]` пул auto release pool сам себя релизит - не надо его релизить.

---

### Очистка свойств класса

При выключенном ARC нужны махинации. Пример геттера:

```objectivec
- (NSString *)name {
    return [[_name retain] autorelease];
}
```

Применение retain-autorelease - это "расширенный способ", в большинстве случаев используется просто возврат instanceVariable.

retain увеличивает счетчик на 1, autorelease уменьшает на 1. Разобраться дома с этой конструкцией. Кто сможет - тому 5.

---

`NSObject#dealloc` используется для очистки памяти.

---

### Слабые ссылки

В ARC - это ключевое слово weak для свойств, в MRC - assign.

assign в ARC используется для примитивных типов, но можно и для указателей. Отличие в том, что счетчик ссылок не увеличивается, но при этом указатель не устанавливается в nil -> висящий указатель. Этим assign хуже.

unsafe_unretained - небезопасный, не увеличивающий счетчик. Это аналог assign для указателей. Используется в кейсах оптимизации.

---

Профайлер показывает узкие места кода, которые можно оптимизировать.

---

Делегат объявляется слабой assign ссылкой, чтобы не было цикла удержания

```
---------- порождает   -----
|Владелец| ---------> | Obj |
---------- <- - - - -  -----  
Счетчик=1              Счетчик=1
```
---

Альтернативные коллекции (NSPointerArray etc.) для работы со слабыми ссылками - при добавлении указателя в них счетчик ссылок не увеличивается.

---

Пример мини-оптимизации в сеттере с retain:

```objectivec
- (void)setName:(NSString *)name {
  if (_name != name) {
    [_name release]; // Освобождаем старый объект
    _name = [name retain]; // Увеличиваем счетчик ссылок на новый
                           //объект и ставим на него указатель _name
  }
}
```

---

Dealloc в случае ARC нужно использовать в случае использования assign для указателей или unsafe_unretained. В нем указатель нужно занилить.


---

### Категории и ассоциативные свойства

В них используйте assign для слабых ссылок и dealloc с их занулением.

---


### Блоки

Блоки - это тоже объекты в куче, поэтому они могут приводить к циклам удержания. При захвате указателей они удерживают их строгой ссылкой, счетчик увеличивается на 1.

```
Кл.1 --------> Кл.2 -----------> Блок
   \              \ -------------/ /
     -----------------------------/
```

Цикл удержания надо всегда разрывать. Для этого используется специальный кастинг к слабым ссылкам. А внутри блоков они кастятся в strong (хотя в большинстве случаев можно использовать weak, т.к. в Obj-C посылка сообщения в ноль не приводит к ошибке, если self умрет).

 ```objectivec
 - (void) viewDidLoad 
 {
     __weak __typeof(self) weakSelf = self;
	 
	 self.completion = ^() 
	 {
		 __strong __typeof(weakSelf)strongSelf = weakSelf;
		 strongSelf.view.alpha = 1;
	 }
	 
	 // надо ли приводить к weakSelf? [No]
	 [UIView animateWithDuration:1 animations:^{
	      self.view.alpha = 1;
	 }];
 }
 ```
 
 Почему не надо приводить к weakSelf? Нет, так как нет связи с объектом и второй связи. Блок извне не удерживается.
 
 У блоков есть свой реализованный dealloc, в котором релизятся захваченные сильные ссылки.
 
 ---
 
 Обращайте внимание на разницу конструкций:
 
 ```objectivec
 [p message];
 p->sth; // может вызвать крэш в отличие от первой строки
 ```
 
 ---
 
 ### Синглтоны
 
 Нужно следить чтобы не было циклов удержания с сильными ссылками из синглтона. Т.к. синглтоны сами никогда не уничтожаются и будет зависание и утечка.
 
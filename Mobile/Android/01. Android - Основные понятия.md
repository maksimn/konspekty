# Android

### 1. Особенности приложения в Android OS

Приложение в Android - это пакет, который система запускает внутри фреймворка. "Внутри фреймворка" означает, что в приложении, в отличие от десктопа, нет статического метода `main()`, а приложение работает через callback'и компонентов этого приложения.


__Что такое пакет apk:__

* Исполняемый код (специфический код данного приложения + код библиотек; пакет android в код не входит - классы из него доступны только в runtime).
* Ресурсы (строки, картинки, шрифты...)
* AndroidManifest - дескриптор, описывает, какие в приложении есть activity, какие content provider'ы, и на какие системные события вы хотели бы получать уведомления (через broadcast receiver).

__Как запускается наш пакет (приложение) (упрощенно)__

1. Запускается java машина
2. Запускается метод `android.app.ActivityThread.main()` - это метод из андроида, а не приложения.
3. Инициализируется объект `Application` - через рефлексию создается объект `Application`; если в манифесте вы указали свой, то создастся ваш, у него вызывается метод `onCreate()`.
4. Инициализируется нужный компонент - извне этому `ActivityThread` сообщается, ради какого компонента запустили приложение, он подбирает этот компонент, через рефлексию его создает и пробегает по методам ЖЦ.

__Как приложение функционирует дальше__

Мобильная ОС --> Бережность к ресурсам

Бережность к ресурсам --> Прерывание процесса приложения, при нехватке ресурсов

_Одна из сложностей мобильной разработки_: ОС Android ожидает, что приложение восстанавливается после восстановления процесса

==> Требования к архитектуре приложения: Архитектура приложения должна предусматривать прерывание процесса и последующее восстановление.


Как система помогает приложению восстановиться

* ОС управляет стеком Activity Stack
* `Activity.onCreate(Bundle savedInstanceState)` - можно сохранить что-то в `Bundle`, это вам известно.
* `View.SavedState` - вьюхи могут восстанавливаться.

Это поведение означает сильную связь между ОС и приложением. Поэтому надо знать, что такое манифест.

__Основные компоненты приложения__:

__Activity__ – даёт возможность показать пользователю экран приложения

__Layout__ - раскладка - задает вид экрана.

__Activity__ - задает то, что приложение делает. Это специальный Java-класс, определяющий, какую раскладку использовать, и какой ответ выдавать пользователю. Например, обработку нажатия кнопки.

_Доп. ресурсы_ - картинки и т. д.

---

### Android manifest

Файл `AndroidManifest.xml` есть у каждого приложения. Содержит

* список activity приложения
* используемые библиотеки.
* прочие объявления

Также в нем задается

* название пакета приложения (например, `com.yandex.maps`)
* иконки приложения
* тема

Пример минимального манифеста, с которым можно скомпилить приложение.

```
<?xml version="1.0" encoding="utf-8"?>
<manifest package="mini.mum" />
```

Хотя gradle добавит в него несколько строк.

В манифесте можно описать компоненты, вспомним их.

Одна из активностей задается как главная (`MAIN`).

Объявлена должна быть каждая активность.

```
<application ...>
  <activity android:name=".MyActivityClassName" ...>
    ...
  </activity>
  ...
</application>
```

Объявление активности может иметь другие свойства, например, относящиеся к
* безопасности
* может ли активность использоваться активностями другого приложения.


---

Запуск Activity

* `startActivity(Intent)`
* `startActivityForResult(Intent)` - запуск активности, если вам нужно получить что-то от другого приложения.

```
setResult(Intent) // вызываемое приложение делает set результата
onActivityResult(Intent) // можно получить резалт
```


Intent filter

```
<activity
    android:name="..."
    android:excludeFromRecents="true">
  <intent-filter>
    <action android:name="android.intent.action.SEND"/>
    <action android:name="android.intent.action.SEND_MULTIPLE"/>
    <data android:mimeType="*/*"/>
    <category android:name="android.intent.category.DEFAULT"/>
  </intent-filter>
</activity>
```

Это манифест для uploader'а файлов на сервер.

Рекомендация: Не заводите Activity без веских на то причин

__ContentProvider__ – даёт возможность предоставить данные другим приложениям

Рекомендация: Не заводите ContentProvider без веских на то причин

__Service__ – даёт возможность работать приложению в фоне. Это очень важно

Что можно сделать с Service

* `startService(Intent)` / `stopService(Intent)`
* `bindService(Intent)` - можно прибиндиться.
* `startForeground(int, Notification)` - Foreground Service - это "сервис с UI"

Запущенный Service не означает бессмертный процесс. Система может его "убить".

Примеры неудачного использования Service - другая ошибка начинающего - сделать сервисы центром приложения и всё делать через них.

1. Прогонять всё через `Service.onStartCommand(Intent)`
2. Использование Bound Service в том же процессе


Рекомендация: не стройте приложение вокруг Service

Пример удачного использования Service

Service как флаг, связанный с состоянием операций в j.u.c.Executor

__BroadcastReceiver__ – даёт возможность принимать события от системы и других приложений - это __приемник__

Что можно сделать с broadcast

1) `sendBroadcast(Intent)` - это __источник__ для broadcast

2) Broadcast receiver можно объявить в манифесте:

```
<receiver android:name="...">
    <intent-filter> ... </> </>
```

в этом случае система создаст и запустит для нас процесс, если такое событие произойдет.

3) `registerReceiver(BroadcastReceiver, IntentFilter)`

можно вешать и снимать broadcast receiver'ы в момент работы вашего процесса. Например, вы upload'ите большой файл. В этот момент, как только начинается отгрузка, вы вешаете BR и как только получили событие, что у вас не хватает батарейки, вы прекращаете отгрузку и отвешиваете BR.

Рекомендация: Не используйте Broadcast как EventBus внутри своего приложения.

Event Bus - это паттерн. Знаете?

(Источник для send) <--> [шина context] <--> (reqister для приема)

Использовать дефолтный br - это жестко, т.к. событие является системным. 

Есть local broadcast receiver - это тот же самый интерфейс, который реализует объект, который идет в compat'е. Тоже не вариант, т.к. неудобен.

За решением проблемы идите в Android Arsenal и ищите подходящий Event Bus, если он вам нужен в приложении. Но это коварная вещь т.к. одно событие может породить event storm.

__Permissions__ – даёт возможность ограничить доступ к нашим компонентам.

Android - безопасная система, и она не даст приложению ничего, если оно само об этом не попросит. 

Здесь есть некоторые неочевидные вещи. Например, у вас есть приложение, которое процессит файлы в background. Ну, имеется в виду, что требуется вычислительная мощность в background. Вы запустили сервис, но это для системы не означает, что телефон не может засыпать. И вы должны захватить wake lock. Он не позволит телефону уснуть, это приводит к разряду батарейки, это критически важный ресурс - значит, его нужно защитить. 

Система заставляет нас декларировать этот permission. Запрос permission

```
<uses-permission
    android:name="android.permission.WAKE_LOCK"/>
```

Вы можете использовать permission для того, чтобы наладить коммуникацию между своими приложениями. У вас не одно приложение, а много, и вы хотите, чтобы какие-то компоненты были доступны только вашим приложениям. Вы объявляете свой permission в одном приложении и говорите, что "я хочу его использовать в другом приложении". Это задается через `android:protectionLevel="signature"` - что только вашим приложениям можно пользоваться этим permission.

```
<permission
    android:name="my.app.permission.MY_PERM"
    android:protectionLevel="signature"/>
...
<uses-permission
    android:name="my.app.permission.MY_PERM"/>
```

Пример невнимательного чтения документации. В приложении надо было добавить функциональность backup SMS и т.д. Для этого нужен permission для чтения смсок.

```
<uses-permission
    android:name="android.permission.READ_SMS"/>

<uses-feature
    android:name="android.hardware.telephony"
    android:required="false"/>
```

Вывод из чужих ошибок: внимательно читайте документацию

---

### Папка res/

Умение работать с res позволяет в некоторых случаях обходиться без написания Java кода.

Что будем понимать под ресурсами: Всё, что лежит в apk, кроме исполняемого файла и AndroidManifest.

Как добавить ресурсы в apk мимо папки res/ (альтернативные способы добавления ресурсов)

1. resources/ - из Java SE. Этот способ хорош тем, что в нем не нужно передавать контекст, можно получить ресурс статическим вызовом.
2. assets/ - андроидный способ; отличается от первого тем, что в него можно вкладывать папки.

Свойства resources/ и assets/

* статические ресурсы
* сырые данные - работаете с `InputStream`, как вы там его будете парсить - ваше дело.

Свойства res/. Как облегчить жизнь разработчику?

* ресурсы выбираются для текущей конфигурации (для языка, ориентации устройства)
* может получить готовые объекты

Использование res/ в коде

* `android.content.res.Resources` – менеджер ресурсов
* `my.app.R.*` – ключи ресурсов

Квалификаторы - применяются в менеджере для предоставления ресурсов в зависимости от конфигурации

* county code
* network code
* __locale__
* layout direction
* __smallest screen width__ - разные ресурсы для разных размеров экрана
* screen width
* screen height
* size
* ration
* __orientation__ - разные layout для разной ориентации
* ui mode
* night mode
* __density__
* touch screen
* keyboard
* text input
* navigation state
* navigation method
* dimension
* __version__ - ресурсы разные для разных версий ОС.

Какой ресурс выберет Resources?

```
values/
values-v23/ 
values-land/ - этот.
```

Запускаем на v23 и смотрим в land

Какой ресурс выберет Resources?

```
values/
values-v23/
values-land/
values-land-v19/ - тоже этот
```

Запускаем на v23 и смотрим в land

Пример использования модификаторов

Задача: Есть картинка с текстом. Для ru и uk надо использовать кириллицу, а для остальных латиницу

Пример использования модификаторов. Лобовое решение

```
drawable-xxxhdpi/pic.png
drawable-ru-xxxhdpi/pic.png
drawable-uk-xxxhdpi/pic.png
```

Умное решение

```
drawable-xxxhdpi/pic_latin.png
drawable-xxxhdpi/pic_cyrillic.png
```


drawable/drawables.xml

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item name="drawable">@drawable/pic_latin.png</item>
</resources>
```

```
drawable-ru/drawables.xml
drawable-uk/drawables.xml
```

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item name="drawable">@drawable/pic_cyrillic.png</item>
</resources>
```

Типы ресурсов

* integer
* integer-array
* interpolator
* layout
* menu
* mipmap - можно получить картинку с density, не соответствующему вашему телефону.
* __plurals__ - возможность в зависимости от переданного числа получить разные строки - "1 студент", "2 студента", "5 студентов".
* __raw__ - например, html как raw ресурсы для разных языков. Без строковых простыней.
* style
* string
* anim
* animator
* array
* bool
* color
* declare-styleable
* dimen
* drawable
* fraction
* id
* string-array
* transition
* xml

Вывод из чужих ошибок:  Перечитывайте документацию, т.к. она меняется.

Пусть нашему приложению нужна картинка `somePicture.png` в качестве ресурса. Куда ее разместить? В папку `res/drawable/`.

Тогда в коде к данной картинке можно обращаться через `R.drawable.somePicture`.

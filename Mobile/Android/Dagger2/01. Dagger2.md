# Dagger2

Dagger2 - это библиотека для внедрения зависимостей, которая выполняет функции

* Фабричных классов
* Service Loader'ов
* Оберток (wrapper'ов)

Dagger2 удобно применять для

* тестов
* выбирать разные классы для dev и prod версий приложения. 
* для reusable модулей во всем приложении

Dagger2 построен на основе идеи генерации кода во время компиляции, а не рефлексии во время выполнения.

---

Пример использования Dagger2 - Кофе-машина (Coffee Maker).

## Объявление зависимостей

Dagger2 отвечает за создание экземпляров классов вашего приложения. 

Аннотация __@Inject__ используется для указания конструктора, который будет использоваться Dagger'ом для создания экземпляров данного класса. 

```java
class Thermosiphon implements Pump {
    private final Heater heater;

    @Inject
    Thermosiphon(Heater heater) {
        this.heater = heater;
    }

    // ...
}
```

При запросе нового экземпляра класса Thermosiphon в коде приложения, Dagger2 получит объекты, необходимые в качестве параметров этого конструктора, вызовет этот конструктор и вернет экземпляр этого класса. (__Внедрение зависимостей через конструктор__).

Dagger2 может внедрять зависимости напрямую для полей (__внедрение зависимостей через поле__):

```java
class CoffeeMaker {
    @Inject Heater heater;
    @Inject Pump pump;
    // ...
}
```

Если у класса есть поля, аннотированные __@Inject__, но не имеется конструктора, аннотированного __@Inject__, то Dagger осуществит внедрение зависимостей для данных полей, если они будут запрашиваемыми, но не будет создавать новые экземпляры [данного класса]. Добавьте конструктор без аргументов с аннотацией __@Inject__, чтобы указать Dagger'у, что он может создавать экземпляры. Классы, у которых отсутствует аннотация __@Inject__, не могут конструироваться Dagger'ом. 

Также в Dagger есть __внедрение зависимостей через метод__, но это реже используется, чем первые 2 способа.

###  Выполнение зависимостей

По умолчанию Dagger выполняет каждую зависимость, конструируя объект запрашиваемого типа так, как это описано выше.

При запросе объекта `CoffeeMaker`, он его получает вызовом `new CoffeeMaker()` и делает внедрение полей.

Но аннотация __@Inject__ подходит не во всех случаях:
* Нельзя инстанцировать объект интерфейса
* Нельзя приписать аннотацию сторонним (third-party) классам
* Некоторые объекты требуют дополнительной конфигурации

В этих случаях, когда __@Inject__ недостаточен или неудобен, для выполнения зависимости используйте _метод, аннотированный_ __@Provides__. Возвращаемый тип этого метода определяет зависимость, которую он выполняет.

Например, там где требуется объект `Heater`, будет вызываться метод `provideHeater()`:

```java
@Provides static Heater provideHeater() {
    return new ElectricHeater();
}
```

Возможно, что методы с __@Provides__ сами имеют зависимости. Данный метод возвращает объект `Thermosiphon`, когда требуется получить объект `Pump` 

```java
@Provides static Pump providePump(Thermosiphon pump) {
    return pump;
}
```

Методы с __@Provides__ должны быть заданы внутри _модуля_ - класса, аннотированного __@Module__:

```java
@Module
class DripCoffeeModule {
    @Provides static Heater provideHeater() {
        return new ElectricHeater();
    }

    @Provides static Pump providePump(Thermosiphon pump) {
        return pump;
    }
}
```

СОГЛАШЕНИЕ: 
* методы с __@Provides__ имеют префикс `provide`
* классы модулей имеют суффикс `Module`

### Создание графа зависимостей

Классы с аннотациями __@Inject__ и __@Provides__ образуют граф объектов, связанных их зависимостями. 

Вызывающий код (метод `main()` или метод класса `Application` в Android) обращается к этому графу через заданный набор корней. Этот набор определяется интерфейсом, методы которого 
* не имеют аргументов
* возращаемый тип - тип, который мы хотим получить.

К этому интерфейсу применяется аннотация __@Component__ и в ней передается тип модуля через параметр `modules`:

```java
@Component(modules = DripCoffeeModule.class)
interface CoffeeShop {
    CoffeeMaker maker();
}
```

После этого Dagger2 генерирует полную реализацию данного контракта. Эта реализация имеет то же имя, что этот интерфейс, но с префиксом __Dagger__ (т. е. __DaggerCoffeeShop__).

Получите экземпляр этого интерфейса __CoffeeShop__, вызывая метод __builder()__ этой реализации, и __используйте возвращенный builder для задания зависимостей__, а после - метод __build()__, который вернет новый экземпляр __CoffeeShop__:

```java
CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
    .dripCoffeeModule(new DripCoffeeModule())
    .build();
```

Если интерфейс с __@Component__ вложенный, как

```java
class Foo {
    static class Bar {
        @Component
        interface BazComponent {}
    }
}
```

то сгенерируется компонент с именем __DaggerFoo_Bar_BazComponent__.

В коде `DaggerCoffeeShop.builder().dripCoffeeModule(new DripCoffeeModule()).build()` любой модуль с доступным конструктором по умолчанию может быть опущен, так как билдер создаст экземпляр автоматически, даже если ничего не задано. Кроме того, в случае, когда у модуля методы с __@Provides__ все только статические, экземпляр вообще не нужен реализации контракта __CoffeeShop__.

Если все зависимости могут быть сконструированы без необходимости в пользователе, создающем экземпляр зависимости, то генерируемая реализация контракта также будет иметь метод __create()__, который может использоваться, чтобы получить новый экзмепляр реализации контракта __CoffeeShop__ без необходимости иметь дело с билдером:

```java
CoffeeShop coffeeShop = DaggerCoffeeShop.create();
```

Теперь наше приложение может просто использовать сгенерированную Dagger'ом реализацию __CoffeeShop__, чтобы получить объект __CoffeeMaker__, для которого произведено внедрение всех зависимостей:

```java
public class CoffeeApp {
    public static void main(String[] args) {
        CoffeeShop coffeeShop = DaggerCoffeeShop.create();
        CoffeeMaker coffeeMaker = coffeeShop.maker();
		coffeeMaker.brew();
    }
}
```

Теперь граф зависимостей построен и осуществлено внедрение зависимостей во входной точке приложения, поэтому его можно запустить. Результат:

```
$ java -cp ... coffee.CoffeeApp
~ ~ ~ heating ~ ~ ~
=> => pumping => =>
 [_]P coffee! [_]P
```


# Dagger2

Dagger2 - это библиотека для внедрения зависимостей, которая выполняет функции

* Фабричных классов
* Service Loader'ов
* Оберток (wrapper'ов)

Dagger2 удобно применять для

* тестов
* выбирать разные классы для dev и prod версий приложения. 
* для reusable модулей во всем приложении

Dagger2 построен на основе идеи генерации кода во время компиляции, а не рефлексии во время выполнения.

---

Пример использования Dagger2 - Кофе-машина (Coffee Maker).

## Объявление зависимостей

Dagger2 отвечает за создание экземпляров классов вашего приложения. 

Аннотация __@Inject__ используется для указания конструктора, который будет использоваться Dagger'ом для создания экземпляров данного класса. 

```java
class Thermosiphon implements Pump {
    private final Heater heater;

    @Inject
    Thermosiphon(Heater heater) {
        this.heater = heater;
    }

    // ...
}
```

При запросе нового экземпляра класса Thermosiphon в коде приложения, Dagger2 получит объекты, необходимые в качестве параметров этого конструктора, вызовет этот конструктор и вернет экземпляр этого класса. (__Внедрение зависимостей через конструктор__).

Dagger2 может внедрять зависимости напрямую для полей (__внедрение зависимостей через поле__):

```java
class CoffeeMaker {
    @Inject Heater heater;
    @Inject Pump pump;
    // ...
}
```

Если у класса есть поля, аннотированные __@Inject__, но не имеется конструктора, аннотированного __@Inject__, то Dagger осуществит внедрение зависимостей для данных полей, если они будут запрашиваемыми, но не будет создавать новые экземпляры [данного класса]. Добавьте конструктор без аргументов с аннотацией __@Inject__, чтобы указать Dagger'у, что он может создавать экземпляры. Классы, у которых отсутствует аннотация __@Inject__, не могут конструироваться Dagger'ом. 

Также в Dagger есть __внедрение зависимостей через метод__, но это реже используется, чем первые 2 способа.

###  Выполнение зависимостей

По умолчанию Dagger выполняет каждую зависимость, конструируя объект запрашиваемого типа так, как это описано выше.

При запросе объекта `CoffeeMaker`, он его получает вызовом `new CoffeeMaker()` и делает внедрение полей.

Но аннотация __@Inject__ подходит не во всех случаях:
* Нельзя инстанцировать объект интерфейса
* Нельзя приписать аннотацию __@Inject__ сторонним (third-party) классам
* Некоторые объекты требуют дополнительной конфигурации

В этих случаях, когда __@Inject__ недостаточен или неудобен, для выполнения зависимости используйте _метод, аннотированный_ __@Provides__. Возвращаемый тип этого метода определяет зависимость, которую он выполняет.

Например, там где требуется объект `Heater`, будет вызываться метод `provideHeater()`:

```java
@Provides static Heater provideHeater() {
    return new ElectricHeater();
}
```

Возможно, что методы с __@Provides__ сами имеют зависимости. Данный метод возвращает объект `Thermosiphon`, когда требуется получить объект `Pump` 

```java
@Provides static Pump providePump(Thermosiphon pump) {
    return pump;
}
```

Методы с __@Provides__ должны быть заданы внутри _модуля_ - класса, аннотированного __@Module__:

```java
@Module
class DripCoffeeModule {
    @Provides static Heater provideHeater() {
        return new ElectricHeater();
    }

    @Provides static Pump providePump(Thermosiphon pump) {
        return pump;
    }
}
```

СОГЛАШЕНИЕ: 
* методы с __@Provides__ имеют префикс `provide`
* классы модулей имеют суффикс `Module`

### Создание графа зависимостей

Классы с аннотациями __@Inject__ и __@Provides__ образуют граф объектов, связанных их зависимостями. 

Вызывающий код (метод `main()` или метод класса `Application` в Android) обращается к этому графу через заданный набор корней. Этот набор определяется интерфейсом, методы которого 
* не имеют аргументов
* возращаемый тип - тип, который мы хотим получить.

К этому интерфейсу применяется аннотация __@Component__ и в ней передается тип модуля через параметр `modules`:

```java
@Component(modules = DripCoffeeModule.class)
interface CoffeeShop {
    CoffeeMaker maker();
}
```

После этого Dagger2 генерирует полную реализацию данного контракта. Эта реализация имеет то же имя, что этот интерфейс, но с префиксом __Dagger__ (т. е. __DaggerCoffeeShop__).

Получите экземпляр этого интерфейса __CoffeeShop__, вызывая метод __builder()__ этой реализации, и __используйте возвращенный builder для задания зависимостей__, а после - метод __build()__, который вернет новый экземпляр __CoffeeShop__:

```java
CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
    .dripCoffeeModule(new DripCoffeeModule())
    .build();
```

Если интерфейс с __@Component__ вложенный, как

```java
class Foo {
    static class Bar {
        @Component
        interface BazComponent {}
    }
}
```

то сгенерируется компонент с именем __DaggerFoo_Bar_BazComponent__.

В коде `DaggerCoffeeShop.builder().dripCoffeeModule(new DripCoffeeModule()).build()` любой модуль с доступным конструктором по умолчанию может быть опущен, так как билдер создаст экземпляр автоматически, даже если ничего не задано. Кроме того, в случае, когда у модуля методы с __@Provides__ все только статические, экземпляр [модуля] вообще не нужен реализации контракта __CoffeeShop__.

Если все зависимости могут быть сконструированы без необходимости в пользователе, создающем экземпляр зависимости, то для этого генерируемая реализация контракта также имеет метод __create()__, который может использоваться, чтобы получить новый экзмепляр реализации контракта __CoffeeShop__ без необходимости иметь дело с билдером:

```java
CoffeeShop coffeeShop = DaggerCoffeeShop.create();
```

Теперь наше приложение может просто использовать сгенерированную Dagger'ом реализацию __CoffeeShop__, чтобы получить объект __CoffeeMaker__, для которого произведено внедрение всех зависимостей:

```java
public class CoffeeApp {
    public static void main(String[] args) {
        CoffeeShop coffeeShop = DaggerCoffeeShop.create();
        CoffeeMaker coffeeMaker = coffeeShop.maker();
		coffeeMaker.brew();
    }
}
```

Теперь граф зависимостей построен и осуществлено внедрение зависимостей во входной точке приложения, поэтому его можно запустить. Результат:

```
$ java -cp ... coffee.CoffeeApp
~ ~ ~ heating ~ ~ ~
=> => pumping => =>
 [_]P coffee! [_]P
```

#### Binding'и в графе

Пример выше показывает, как сконструировать компонент с одним из наиболее типичных биндингов, но имеется много других механизмов для добавления биндингов в граф:

* Через метод с __@Provides__ внутри класса с __@Module__, на который передается ссылка напрямую через аннотацию __@Component__.__modules__ или транзитивно через __@Module__.__includes__
* Чере любой тип с __@Inject__, который не относится к scope [_здесь возникает это неописанное пока понятие_ - прим.], или имеет аннотацию __@Scope__, соответствующую одному из scope компонента.
* Через методы предоставления компонента или зависимости компонента
* Через сам компонент
* Через билдеры без квалификатора для любого включаемого подкомпонента
* Через Provider или lazy-обертки для одного вышеприведенного способа биндинга
* Через Provider от lazy от одного их вышеприведенных биндингов (т.е. __Provider__<__Lazy__<__CoffeeMaker__>>)
* Через __MembersInjector__ для любого типа


### Singletons и Scoped Bindings

Для реализации одиночного объекта аннотируйте метод с __@Provides__ или внедряемый класс аннотацией __@Singleton__.

```java
@Provides @Singleton static Heater provideHeater() {
    return new ElectricHeater();
}
```

Также аннотация __@Singleton__ для внедряемого класса указывает, что этот объект может быть разделяем между потоками.

```java
@Singleton
class CoffeeMaker {
    ...
}
```
Поскольку Dagger2 связывает scoped-экземпляры в графе с экземплярами реализаций компонентов, то самим компонентам нужно объявить, какой scope они репрезентируют. 

Например, нет никакого смысла иметь компонент, одновременно имеющий биндинги __@Singleton__ и __@RequestScoped__, так как эти scope имеют разный ЖЦ и поэтому должны относиться к компонентам с разными ЖЦ.

Чтобы объявить, что компонент связан с данным scope, просто примените аннотацию scope'а к интерфейсу компонента.

```java
@Component(modules = DripCoffeeModule.class)
@Singleton
interface CoffeeShop {
    CoffeeMaker maker();
}
```

Компоненты могут иметь несколько аннотаций scope'а. Таким образом объявляется, что они все псевдонимы одного и того же scope, и что данный компонент может включать scoped биндинги с любым из объявленных им scope.

### Reusable scope

Иногда вам нужно ограничить количество раз, которое инстанцируется класс через аннотацию __@Inject__, или вызывается метод __@Provides__, но вам не нужно гарантировать, что один и тот же экземпляр будет использоваться в течение всего времени жизни конкретного компонента или подкомпонента. Это может быть полезно в таких окружениях как Андроид, где выделение памяти может быть дорогим.

Для таких биндингов применяют scope __@Reusable__.  __@Reusable-scoped биндинги__, в отличие от других scope, не связаны с каким-либо единичным компонентом; вместо этого каждый компонент, который в действительности использует эту привязку, будет кэшировать возвращенный или инстанцированный объект.

Это значит, что если вы инсталлируете модуль с биндингом __@Reusable__ в компоненте, но в действительности только подкомпонент будет использовать этот биндинг, то только этот подкомпонент будет кэшировать объект биндинга. Если 2 подкомпонента, которые не имеют общего предка, оба используют этот биндинг, то каждый из них будет кэшировать свой собственный объект. Если предок компонента уже закэшировал этот объект, то подкомпонент будет переиспользовать его.

Нет гарантии, что компонент вызовет этот биндинг только 1 раз, поэтому применение __@Reusable__ к биндингам, которые возвращают мутабельные объекты, или объекты, для которых важно ссылаться на один и тот же экземпляр, являются опасными. __@Reusable__ безопасен для неизменяемых объектов, которые вы оставляете unscoped, если вам не важно, сколько раз они были аллоцированы.

```java
@Reusable // It doesn't matter how many scoopers we use, but don't waste them.
class CoffeeScooper {
    @Inject CoffeeScooper() {}
}

@Module
class CashRegisterModule {
    @Provides
    @Reusable // DON'T DO THIS! You do care which register you put your cash in.
            // Use a specific scope instead.
    static CashRegister badIdeaCashRegister() {
        return new CashRegister();
    }
}

@Reusable // DON'T DO THIS! You really do want a new filter each time, so this
          // should be unscoped.
class CoffeeFilter {
    @Inject CoffeeFilter() {}
}
```

### Ленивые внедрения

Иногда нужен объект, который инстанцируется лениво. Для любого биндинга Т вы можете создать `Lazy<T>`, который отложить инстанцирование до первого вызова `Lazy<T>#get()`. Если Т - это одиночка, то `Lazy<T>` будет одним и тем же экземпляром в графе объектов. В ином случае в каждом месте внедрения будет свой собственный экземпляр `Lazy<T>`. Последующие вызовы вернут один и тот же экземпляр Т.

```java
class GrindingCoffeeMaker {
    @Inject Lazy<Grinder> lazyGrinder;

    public void brew() {
        while (needsGrinding()) {
            // Grinder created once on first call to .get() and cached.
            lazyGrinder.get().grind();
        }
    }
}
```

### Внедрения провайдеров

Иногда вместо внедрения единственного значения вам нужны множественные экземпляры. Для этого можно внедрить `Provider<T>` вместо просто Т. `Provider<T>` вызывает логику привязки для Т каждый раз, когда вызывается `.get()`. Если этой логикой привязки является конструктор `@Inject`, то будет создаваться новый экземпляр, но метод с аннотацией `@Provides` не имеет такой гарантии.

```java
class BigCoffeeMaker {
  @Inject Provider<Filter> filterProvider;

  public void brew(int numberOfPots) {
    ...
    for (int p = 0; p < numberOfPots; p++) {
      maker.addFilter(filterProvider.get()); //new filter every time.
      maker.addCoffee(...);
      maker.percolate();
      ...
    }
  }
}
```

Замечание: внедрение `Provider<T>` имеет вероятность создания запутанного кода, и являться проявлением плохого дизайна из объектов с плохим scope и плохой структурой в вашем графе. 
	
Часто вам будет нужно использовать фабрику, `Lazy<T>` или переделать ЖЦ и структуру вашего кода для того, чтобы просто внедрить Т.
	
Внедрение `Provider<T>`, однако, может спасти в некоторых случаях. Например, если у вас есть унаследованная архитектура, которая не соответствует естественному ЖЦ ваших объектов (например, сервлеты).


### Квалификаторы

Иногда только типа недостаточно, чтобы определить зависимость. Например, сложное приложение для создания кофе может требовать отдельный нагреватель для воды и для тарелочки.

В этом случае добавляется __аннотация-квалификатор__. Это любая аннотация, которая сама имеет аннотацию __@Qualifier__. Например, есть аннотация `@Named` из `javax.inject`:

```java
@Qualifier
@Documented
@Retention(RUNTIME)
public @interface Named {
  String value() default "";
}
```

Вы можете просто использовать `@Named`, или создать собственную аннотацию-квалификатор. 

Применение квалификатора:

```java
class ExpensiveCoffeeMaker {
  @Inject @Named("water") Heater waterHeater;
  @Inject @Named("hot plate") Heater hotPlateHeater;
  ...
}
```

```java
@Provides @Named("hot plate") static Heater provideHotPlateHeater() {
  return new ElectricHeater(70);
}

@Provides @Named("water") static Heater provideWaterHeater() {
  return new ElectricHeater(93);
}
```

Зависимость не может иметь более 1 аннотации-квалификатора.


### Необязательные биндинги


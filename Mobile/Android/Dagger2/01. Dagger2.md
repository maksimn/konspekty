# Dagger2

Dagger2 - это библиотека для внедрения зависимостей, которая выполняет функции

* Фабричных классов
* Service Loader'ов
* Оберток (wrapper'ов)

Dagger2 удобно применять для

* тестов
* выбирать разные классы для dev и prod версий приложения. 
* для reusable модулей во всем приложении

Dagger2 построен на основе идеи генерации кода во время компиляции, а не рефлексии во время выполнения.

---

Пример использования Dagger2 - Кофе-машина (Coffee Maker).

## Объявление зависимостей

Dagger2 отвечает за создание экземпляров классов вашего приложения. 

Аннотация __@Inject__ используется для указания конструктора, который будет использоваться Dagger'ом для создания экземпляров данного класса. 

```java
class Thermosiphon implements Pump {
    private final Heater heater;

    @Inject
    Thermosiphon(Heater heater) {
        this.heater = heater;
    }

    // ...
}
```

При начале работы с экземпляром класса Thermosiphon в коде приложения, Dagger2 получит объекты, необходимые в качестве параметров этого конструктора, вызовет этот конструктор и вернет экземпляр этого класса. (__Внедрение зависимостей через конструктор__).

Dagger2 может внедрять зависимости напрямую для полей (__внедрение зависимостей через поле__):

```java
class CoffeeMaker {
    @Inject Heater heater;
    @Inject Pump pump;
    // ...
}
```

Если у класса есть поля, аннотированные __@Inject__, но не имеет конструктора, аннотированного __@Inject__, то Dagger осуществить внедрение зависимостей для данных полей, если они будут запрашиваемыми, но не будет создавать новые экземпляры [данного класса]. Добавьте конструктор без аргументов с аннотацией __@Inject__, чтобы указать Dagger'у, что он может создавать экземпляры. Классы, у которых отсутствует аннотация __@Inject__, не могут конструироваться Dagger'ом. 

Также в Dagger есть __внедрение зависимостей через метод__, но это реже используется, чем первые 2 способа.

###  Выполнение зависимостей

По умолчанию Dagger выполняет каждую зависимость, конструируя объект запрашиваемого типа так, как это описано выше.

При запросе объекта `CoffeeMaker`, он его получает вызовом `new CoffeeMaker()` и делает внедрение полей.

Но аннотация __@Inject__ подходит не во всех случаях:
* Нельзя инстанцировать объект интерфейса
* Нельзя приписать аннотацию сторонним third-party классам
* Некоторые объекты требуют дополнительной конфигурации

В этих случаях, когда __@Inject__ недостаточен или неудобен, для выполнения зависимости используйте _метод, аннотированный_ __@Provides__. Возвращаемый тип этого метода определяет зависимость, которую он выполняет.

Например, там где требуется объект `Heater`, будет вызываться метод `provideHeater()`:

```java
@Provides static Heater provideHeater() {
    return new ElectricHeater();
}
```

Возможно, что методы с __@Provides__ сами имеют зависимости. Данный метод возвращает объект `Thermosiphon`, когда требуется получить объект `Pump` 

```java
@Provides static Pump providePump(Thermosiphon pump) {
    return pump;
}
```

Методы с __@Provides__ должны быть заданы внутри _модуля_ - класса, аннотированного __@Module__:

```java
@Module
class DripCoffeeModule {
    @Provides static Heater provideHeater() {
        return new ElectricHeater();
    }

    @Provides static Pump providePump(Thermosiphon pump) {
        return pump;
    }
}
```

СОГЛАШЕНИЕ: 
* методы с __@Provides__ имеют префикс `provide`
* классы модулей имеют суффикс `Module`


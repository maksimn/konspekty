# Android

## Базы данных и SQLite

Создание таблицы в SQLite

```sql
CREATE TABLE learners (
    id INTEGER PRIMARY KEY,
	name TEXT UNIQUE NOT NULL, // возможно, здесь стоит сделать индекс по имени
	phone TEXT
);
```

Даже если не определить первичный ключ, система создаст его за вас и индекс по нему. Если вы определите его сами (см код), то вы создаёте его псевдоним с указанным именем. Можно просто пользоваться встроенным id-шником.

Для передачи апострофа в строку нужно экранировать его ещё одним апострофом:

```sql
INSERT INTO artists (name,image )
VALUES ('O''Nile', 14);
```

Еще есть проблема, что можно в строку вставить число.

ID строки, который SQLite создаёт за вас, называется `rowid` и он принимает целые значения от 1.

### Функции sqlite

`ifnull()`

```sql
SELECT name, ifnull(image, '<no image>')
FROM artists;
```

`random()` - случайное целое, мб отрицательным.

`group_concat()` - конкатенация строк при `GROUP BY`.

---

В SQLite можно работать одновременно с несколькими БД. Например, соединять таблицы из двух РАЗНЫХ БД:

```sql
ATTACH DATABASE 'database2.sqlite' AS db2;
```

После этого для DML DDL операций используем префикс `db2.`. И работает.

### Транзакции БД

В sqlite есть транзакции

```sql
BEGIN TRANSACTION;

INSERT INTO db2.images
SELECT * FROM images;

INSERT INTO db2.artists
SELECT * FROM main.artists;

END TRANSACTION;
```

Есть ROLLBACK.

### VACUUM

Если в файл БД добавить много данных, а потом удалить их, то размер файла не уменьшится. Для решения этой проблемы есть команда `VACUUM`. Она пересобирает базу целиком.

```sql
VACUUM;
```

Проблема в том, что в течение ее работа с БД заблокирована.

---

## SQLite в Android API

Структура SQLite в Андроид на примере одного запроса.

```sql
select my_column 
from my_table
where column1 = value;
```

Выбираем какие-то данные из таблицы. Тогда мы создаем курсор с запросом и вызываем функцию `query()`

```java
Cursor cursor = db.query("my_table", new String[] {"my_column"}, "column1=?", new String[] {"value"});
```

`db` имеет тип `SQLiteDatabase`. Функция `SQLiteDatabase#query()` не выполняет запрос, а только формирует его и хранит его в объекте `SQLiteQuery`.

Запрос не будет выполнен, пока не будет вызвана функция

```java
cursor.moveToFirst();
```

или `getCount()` и т.п.

Запрос выполнится и это приведет к тому, что часть данных будет скопирована в память. Выполнится внутренняя функция `SQLiteCursor#fillWindow()`, которая выполнит запрос и какой-то кусок данных угонит в память. Курсор -- это итератор с кэшем (1-2МБ). Выходите за границы кэша - прифетчивает еще 1-2МБ.

Что делает функция `SQLiteCursor#fillWindow()`? Всё проходит через некую сессию `SQLiteSession` - сессия - это такой объект, который соответствует каждому потоку. Сессия пытается получить соединение (`SQLiteConnection` через `SQLiteConnectionPool`) - `SQLiteConnection.java` и `SQLiteConnection.cpp` - нативная часть, где самое важное и происходит.

Что важно при разработке на Андроид с использованием sqlite?

* Знание и использование SQLite Android API (и по минимуму SQL запросов) 
* Организация многопоточности - если нужно считывать и записывать данные одновременно, вам нужно создать класс (или еще что-то), который будет это обрабатывать.
* Сделать прозрачную структуру классов - очень часто берут один класс и `SQLiteOpenHelper`, и пихают весь функционал, работающий с БД. Это можно если база данных простая.

### Функции модуля, работающего с БД, которые должны быть вами реализованы

![img alt](images/sqlite_db_module.png "")

Их не так много.

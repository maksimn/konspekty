# RxJava2

## Отличия от RxJava1

RxJava2 переписана на основе спецификации __Reactive-Streams__, которая сама возникла из RxJava1.

### Проблема null

RxJava не работает с null-значениями и в случае получения их выбрасывает NPE немедленно или в виде сигнала по downstream:

```java
Observable.just(null); // NullPointerException at runtime
Single.just(null); // NullPointerException

Observable.fromCallable(() -> null)
    .subscribe(System.out::println, Throwable::printStackTrace); // выводит в 
	// стандартный поток вывода информацию об объекте исключения и стек вызовов
	// (само исключение при этом не выбрасывается)
	
Observable.just(1).map(v -> null)
    .subscribe(System.out::println, Throwable::printStackTrace); // то же самое
```

Поэтому `Observable<Void>` больше не может излучать какие-либо значения, но только завершает работу (обычным образом или с исключением). Вместо него разработчики API могут определить `Observable<Object>`, не гарантирующий то, каким будет этот объект (это в данном случае не важно).

Например, если нужен источник-сигнальщик, то можно определить общее перечисление и передавать его единственный экземпляр в onNext():

```java
enum Irrelevant { INSTANCE; }

Observable<Object> source = Observable.create((ObservableEmitter<Object> emitter) -> {
   System.out.println("Side-effect 1");
   emitter.onNext(Irrelevant.INSTANCE);

   System.out.println("Side-effect 2");
   emitter.onNext(Irrelevant.INSTANCE);

   System.out.println("Side-effect 3");
   emitter.onNext(Irrelevant.INSTANCE);
});

source.subscribe(e -> System.out.println("This BLocK!!!" + e);, Throwable::printStackTrace);
```

Результат выполнения:

```
Side-effect 1
This BLocK!!!INSTANCE
Side-effect 2
This BLocK!!!INSTANCE
Side-effect 3
This BLocK!!!INSTANCE
```

### Observable и Flowable

Flowable - для backpressure.

Хорошая новость, что операторы в основном остались теми же, что в RxJava1.

### Subject'ы и Processor'ы


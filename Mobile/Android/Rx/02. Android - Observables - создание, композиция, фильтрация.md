# RxJava

## Observables - создание, композиция, фильтрация

### Жизненный цикл Observer'a

Если мы хотим получить события от Observable, то нам нужно реализовать интерфейс Observer и вызвать subscribe() на данном Observable. У Observer'a есть 3 метода (см. ранее).

Другой важный интерфейс - Subscription. Этот тип возвращается методом Observables.subscribe(). Единственный метод этого интерфейса - unsubscribe(). Он используется для дисконнекта Observer'a и связанного с ним Observable.

```
| Subscription  |
|---------------|
| unsubscribe() |
```

### Типы Observable

Их 2 в RxJava.

1) Non-blocking Observable, суперкласс Observable.

Для них поддерживается асинхронное выполнение. Для них можно сделать так, чтобы запрос обрабатывался в другом потоке. 

Они также позволяют отписаться в любой точке потока событий. 

По умолчанию RxJava является однопоточной. Асинхронное выполнение создает дополнительный уровень сложности, к которому нельзя относиться несерьезно. 

Вы должны задать выполнение запроса на другом потоке, если вы хотите получить поведение асинхронного выполнения. Далее, если вы хотите поведение параллельного выполнения, а не просто события на другом потоке, отличном от UI-потока, вы должны пройти через дополнительный уровень настройки. 

2) blocking Observable, суперкласс BlockingObservable.

Все вызовы onNext() от такого Observable, будут синхронными - события синхронны. Они не будут выполняться в другом потоке. Методы blocking Observable не принимают шедулеров и исполняются в вызывающем потоке. 

Для них невозможно отписаться посреди потока событий. 

__Вывод__: обращайте внимание на то, какой тип Observalble возвращается тем или иным методом из RxJava.

### Schedulers

RxJava позволяет задать, на каком потоке исполнять код, через использование шедулеров. 

Класс __Schedulers__ предлагает несколько опций

* __computation()__ - шедулер с числом потоков, равных числу ядер на компьютере. (он подходит для вычислений)
* __currentThread()__ - при завершении текущей работы код вашего события будет исполняться на текущем потоке
* __immediate()__ - не дожидается завершения работы и немедленно вызывает обработчик на текущем потоке
* __io()__ - этот шедулер используется long-running IO-процессами. Он подкрепляется пулом потоков, растущим по необходимости для поддержки большего числа ждущих IO-потоков. 
* __newThread()__ - этот шедулер используется, если вы хотите, чтобы создавался новый поток для каждой единицы работы. 
* __executor(Executor)__ - для обертки стандартного Java интерфейса Executor в нужный интерфейс Scheduler, совместимый с RxJava.
* __executor(ScheduledExecutor)__ - перегрузка для ScheduledExecutor из java для интеграции с ним. 

Как Observable использует шедулеры? По умолчанию - однопоточная система. Если ничего не делать, то метод subscribe() и все вызовы событий будут исполняться на одном потоке, вызвавшем метод subscribe(). 

Выполнить код используя другие шедулеры - легко. Задать шедулер нужно самому. 

Есть 2 метода Observable, влияющих на то, как шедулеры используются во время выполнения.

* __subscribeOn(Scheduler)__ - позволяет задать шедулер, определяющий, на каком потоке выполняется код при вызове метода subscribe(). Если не задать шедулер так, то для произведения вызова subscribe() будет использоваться currentThread. Если вы не присвоите шедулер в subscribeOn(), то метод subscribe() будет блокировать, пока все события для данного связанного с ними Observable будут обрабатываться.

Присваивание шедулера в __subscribeOn__ означает, что код, который производит подписку, будет выполняться на одном и только одном потоке, взятом из присвоенного шедулера. 

* __observeOn(Scheduler)__ - задает шедулер для исполнения методов onNext(), onCompleted(), onError() Observer'a. Если его не задать, то будет использоваться шедулер из subscribeOn(). Если шедулер не был задан в subscribeOn(), то метод Observer'a будет вызван, используя тот же самый поток, что и поток, производящий вызов метода subscribe().

Присваивание шедулера в __observeOn__ означает, что код вашего Observer'a будет выполняться на одном и только одном потоке, взятом из этого присвоенного шедулера. Это значит, что Observer'ы не будут параллельными. 

### Создание Observable

Для этого - метод `Observable.from(...)`. 

Принимает - тип события и (при необходимости) шедулер. Если шедулер опущен, то будет использоваться currentThread. 

Если шедулер на задать, то возвращенный Observable будет эффективно блокирующим. 

Другая перегрузка этого метода принимает Iterable<T> и необязательный шедулер. Это версия для работы с Java-коллекциями. 
	
Также есть перегрузка, принимающая массив.

4-я версия - принимает `Future<T>`. Это для взаимодействия со стандартным java concurrency.
	
---

`BlockingObservable.from(...)`

`<T> Observable<T> BlockingObservable.from(Observable o)`

Это блокирующая обертка над переданным Observable.

### Пример создания Observable (код)


### Композиция

Композиция операторов в RxJava для создания небольших и функциональных обработчиков событий. 

Каждый метод класса Observable помогает вам создать цепочку операций.

Например:

1. Извлечь список пользователей из UserService. UserService возвращает список пользователей, который мы завернем в Observable. 

2. Добавить параллельную операцию, так что наш следующий шаг исполнится с использованием computational-шедулера. 

3. Удалить из списка всех пользователей-админов. Это можно выполнить параллельно. 

4. Упорядочение списка пользователей по их правам доступа (по возрастанию). 

5. Генерация JSON для каждого пользователя.

__[CODE]__

### Фильтрация

В RxJava есть следующие операции фильтрования:

* Предикаты 
* Позиционные фильтры - залезть в поток и забрать конкретные offset'ы событий
* Time-based фильтры. В RxJava есть шедулинг на основе временных характеристик с возможностью запуска параллельного кода.

---

## RxJava2


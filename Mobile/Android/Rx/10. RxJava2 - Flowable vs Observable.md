# RxJava2

## Flowable vs Observable

```java
// Observable<MotionEvent>

interface Observer<T> {
    void onNext(T t); // метод, в который передаются приходящие item'ы событий
	                  // и где можно произвести обработку
	void onComplete();
	void onError(Throwable t);
	void onSubscribe(Disposable d); // ! Disposable
}

// метод освобождения ресурса, означающий, что подписавшийся больше не хочет получать коллбэки
// например, его вызов приведет к отмене сетевого запроса
interface Disposable {
    void dispose();
}
```

Бесконечный источник - для него есть только вызовы `onNext()`. 

Для конечного источника - есть дополнительно терминальные события `onComplete()` (завершение с успехом) и `onError()` (завершение с ошибкой - вызов `onNext()` привел к исключению, или есть проблемы с source). После терминальных событий нет никаких идущих за ними вызовов коллбэков `onNext()`, `onError()`, `onComplete()`.

```java
// Flowable<Row>

interface Subscriber<T> {
    void onNext(T t);
	void onComplete();
	void onError(Throwable t);
	void onSubscribe(Subscription d); // ! Subscription
}

interface Subscription {
    void cancel();
	void request(long r); // здесь проявляется backpressure 
	                      // указывает Flowable, что вы готовы получать еще события 
}
```

### onSubscribe(Subscription|Disposable)

При подписке на Flowable или Observable можно считать, что выделяется некий ресурс. Ресурсы надо очищать. Поэтому при подписке будет обязательно вызван этот метод.


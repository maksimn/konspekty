# RxJava

## Понятия реактивного программирования

Цель функционального программирования - сделать код предсказуемым и потокобезопасным. И оно является основой для реактивного программирования. 

Основные понятия функционального программирования:

* __Чистые функции__ 
* __Функции как объекты первого класса__
* __Функции высшего порядка__ - функции, возвращающие другие функции

Понятия реактивного программирования:

* Манифест реактивного подхода
 * Event driven (для многопоточности, сопровождаемости, расширяемости)
 * Масштабируемый (автоматическая реакция на возрастание нагрузки)
 * Эластичный (гладкое поведение при временных отказах удаленных сервисов и т. п.)
 * Отзывчивый для пользователя.

### Чистые функции

Чистая функция не имеет side-эффектов, независимо от того, сколько потоков её вызывают. Поэтому чистые функции имеют предсказуемый результат для заданных входных параметров независимо от количества их вызовов и многопоточности. 

Чистые функции не должны включать операции со временем, IO-операции и т.п. 

### Функции как объекты первого класса

В Java 8 функции можно присваивать в переменные.

Для функций есть определённые типы из `java.util.function`, то есть их можно передавать как параметры в функции.

### Функции высшего порядка

Тип функции (см. выше) можно вернуть из функции как возвращаемое значение. И эта возвращенная функция не будет вызвана, пока этого не потребовать в явном виде (lazy execution).

---

### Event driven

Для этого Rx использует паттерн `Observer`. 

```
                  Observer1
Observable        Observer2
                  Observer3
```

Нотификации наблюдателей могут быть конкурентными. 

В RxJava эти стороны паттерна принимают обобщенный тип события:

```
                     Observer1<T>
Observable<T>        Observer2<T>
                     Observer3<T>
```

В `Observable<T>` возникают события, и они отправляются асинхронно к наблюдателям. Нотификации конкурентны, многопоточность обрабывается за вас. 
	
Наблюдатели пассивны. Они не расходуют ресурсы, пока не получат объект события. 

__Пример event-driven подхода в RxJava__:

```
Observable<User>        -->  Observer<User>
(список пользователей)  -->  (отфильтровывает всех
                        -->   не-админов)
						      |-> Observable<User> --> Observer<User>
										               (группирует пользователей 
													   по классу безопасности)
													   Observable<User>           --> Observer<User>
																                      map ORM User to 
																					  JSON User Bean
																					  -> Observable<User>
```

Имеем `Observable<User>`, которое возвращает события как пользователей. В RxJava можно понимать всё как __списки событий__. RxJava дает инструменты для работы с этими списками и их трансформации. 
	
Между Observable и Observer'ом здесь задаем `Scheduler`, для использования его для выполнения данной операции. И мы задаем возможность распараллеленной его работы.

В RxJava есть несколько разных шедулеров, и мы выберем один из них и он обработает работу с потоками за нас. 

В результате мы снова собираемся получить `Observable<User>`. 
	
Следующая операция - группировка - не может быть сделана параллельно, поэтому мы собираемя сделать ее как последовательную операцию. В результате мы снова получаем следующий `Observable<User>` пользователей, упорядоченных по классу безопасности. 
	
Следующий шаг - отображение типов пользователя. Для этого процесса тоже задается свой шедулер.

В итоге

* __код разбит на поддающиеся контролю этапы в виде функций без side-эффектов__
* __работа с потоками выполняется за нас RxJava__

### Масштабируемость

Детали многопоточности RxJava отрабатывает за вас. Это способствует масштабируемости. 

Пусть есть служба А, которая обращается к трем службам F, G, H. При последовательном обращении к ним общее время работы:

```
T = A + T_f + T_g + T_h
```

При параллельном - 

```
T = A + MAX(T_f, T_g, T_h)
```

### Эластичность

Эластичное приложение:

1. Плавно обрабатывает ошибки. Так, что при ошибке заданного типа можно всё равно вернуть пользователю некоторое значение.

Нужно пытаться обрабатывать больше, чем просто удачный сценарий процесса. И при этом выдавать пользователю осмысленные сообщения. 

2. Управление отказами (failure).

Bulkheads - предотвратить воздействие отказавших в работе компонентов на работающие компоненты. 

Идея _location transparency_ - event-driven код естественным образом состоит из компонентов, для которых не важно, кто вызвал их исполнение и где они выполняются. Это повышает эластичность приложения.

### Отзывчивость

В реактивном подходе мы считаем, что

__Долгий ответ = Отказ__

Низкая производительность = отказ

Можно задать желаемый уровнь производительности, ухудшение которого будет означать отказ. Возможна гибкая настройка метрик производительности, чтобы не были только сплошные отказы.

__Observable Data Models__, MVVM. Обновление модели - автоматическое обновление UI через фоновые потоки.

Потоки событий от пользователей при их действиях.



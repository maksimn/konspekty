### Устройство байткода и из чего состоит .class-файл

Немногие там копались.

Перейдем сразу в недра, в язык Си. Из чего состоит .class файл на этапе компиляции, когда уже есть байткод (промежуточный)?

Это простая структура языка Си.

```
struct ClassFile {
  u4 magic; 
  u2 minor_version; // версии javac, которым был собран текущий файл
  u2 major_version;
  u2 constant_pool_count; // Сonstant Pool
  cp_info constant_pool[constant_pool_count-1];
  u2 access_flags; // Флаги доступа
  u2 this_class; // ссылка на this
  u2 super_class; // ccылка на суперкласс
  u2 interfaces_count;
  u2 interfaces[interfaces_count]; // ссылки на интерфейсы, поля, методы и т.д.
  u2 fields_count;
  field_info fields[fields_count];
  u2 methods_count;
  method_info methods[methods_count];
  u2 attributes_count;
  attribute_info attributes[attributes_count]; // что метод приватный, синхронизованный и т.д.
}
```

Если попытаться .class файл для Java, то получим набор указателей, ссылок, магии, версий и т.д. Что здесь что на самом деле?

Структура заголовка .class файла - это 12 бит, состоит из __magic__

```
0xCAFEBABE
```

это слово, по которому можно найти все .class файлы системы, если сделать поиск по hex. Когда удается получить доступ к файловой системе какого-нибудь сервера, на этом все Java-разработчики обламываются, потому что мы получаем доступ ко всем .class файлам, их не нужно как-то искать - зная смещения, зная размеры, куда и как инжектиться, мы инжектим в абсолютно все Java .class файлы свой код. И в следующий раз при рестарте сервера - "привет" - появляется картинка "я - хакер Х, вас взломал". К счастью, сейчас сервера надежны и такое происходит редко. Так что если вы потеряли .class файлы, это способ легко их найти.

_Constant pool_ - следующая структура. Самая большая структура в .class файле, которая хранит в себе 

* Различные константы класса и предка (константы строк и других объектов, которые мы записываем этот .class файл)
* Названия класса, интерфейсов и суперкласса — как строки
* Имена полей, методов — тоже строки

Позже после компиляции класса все эти названия стираются, в байткоде их нет, и вместо них есть только адреса - адреса смещения -> метод находится там.

Что делает JVM? Она берет смещение, идет в constant pool, берет название, по этому названию ищет нужный класс в DEX loader'е и подгружает его или линкует (в зависимости от того, что произходит в данный момент).

Также в constant pool много чего складывается в процессе выполнения -- туда складываются практически все переменные, которые мы описываем как поля класса. Если мы описываем их как final, то на этапе инстанцирования, т.е. запуска конструкторов все данные будут сохранены в constant pool, чтобы лишний раз не дергать кучу методов/смещений.

Флаги доступа класса (вспомним public, private, package)

* ACC_PUBLIC
* ACC_FINAL
* ACC_SUPER
* ACC_INTERFACE - интерфейс
* ACC_ABSTRACT - флаг и для интерфейса, и для абстрактного класса.
* ACC_SYNTHETIC - для внутреннего класса, доступ к охватывающему классу. Чаще означает класс, сгенерированный в процессе компиляции. Его нет в исходниках, он не настоящий. Поэтому Retrolambda ссылается в пустоту, так как все классы с лямбдами являются синтетическими.
* ACC_ANNOTATION - аннотации
* ACC_ENUM - перечисления

Если сложно, нужен практический пример.

__Bytecode, пример на практике__

```
1: package ru.yandex;
2: //empty
3: public class Example {
4:   public static void main(String[] argv) {
5:     String str1 = new String("test");
6:     String str2 = new String("test");
7:   }
8: }
```

Тут есть ошибка. Но в чем? 

Здесь описано то, во что превращается только одна первая строчка метода main:

```
public static main([Ljava/lang/String;)V
  L0 // индекс процедуры, аналог джавого label, который можно поставить на входе в любой цикл
  LINENUMBER 5 L0 // указатель на строчку в исходном .java файле
  NEW java/lang/String // инстанцирование класса String, кладем ссылку на класс на вершину стека
  DUP //копируем ссылку на вершине стека
  LDC "test" //кладём на стек ссылку на "test" из constant pool

  //вызов конструктора, аргументы берутся со стека
  INVOKESPECIAL java/lang/String.<init> (Ljava/lang/String;)V
  ASTORE 1
  //сохраняем ссылку с вершины стека в локальную переменную сномером 1
```

L0 означает процедуру. Обычно по одному label на одну процедуру.

Здесь мы взяли ссылку на string из constant pool. И, казалось бы, если это повторить ещё раз, то будет проще, можно ещё раз взять ту же самую ссылку. И по идее, если мы сравним 2 строки, они будут равны.

```
  L1 // 2-я строка метода main()
  LINENUMBER 6 L1
  NEW java/lang/String // тот же вызов конструктора и передача ему аргумента
  DUP
  LDC "test"  // но разница в том, что здесь происходит явный boxing
  INVOKESPECIAL java/lang/String.<init> (Ljava/lang/String;)V
  ASTORE 2  // мы говорим, что хотим присвоить не строку, а объект String
  
  // в этом случае строка не присваивается в переменную str2, передается дальше в String

  L2
  LINENUMBER 7 L2
  RETURN  //return void выставляется компилятором
```

Директива INVOKESPECIAL не принимает аргументов, хотя String принимает, а просто берет значение с вершины стека и передает в String.

Строки окажутся не равны друг другу:

```
str1.equals(str2); // true
str1 == str2; // false - сравниваются не значения строк, а значения ссылок на объекты String
```

Поэтому boxing-типы (`Integer` и другие) вообще не следует использовать. Начиная с Android 23 API все конструкторы String сделаны deprecated и выбрасывают exception. Не пишите `new String()`. 

Более корректный пример, где нет упаковки:

```
1: package ru.yandex;
2: //empty
3: public class Example {
4:   public static void main(String[] argv) {
5:     String str1 ="test";
6:     String str2 ="test";
7:   }
8: }
```

Байткод:

```
public static main([Ljava/lang/String;)V
  L0
  LINENUMBER 5 L0
  LDC "test"
  ASTORE 1
  L1
  LINENUMBER 6 L1
  LDC "test"
  ASTORE 2
  // return
```

В чём разница между этими методами? Нет указателя на String, нет INVOKESPECIAL конструктора, код существенно упростился. Просто берем строку из constant pool и сохраняем указатель на String. И всё.

в деталях

```
  LDC "test"
```

versus

```
  NEW java/lang/String
  DUP
  LDC "test"
  INVOKESPECIAL java/lang/String.<init> (Ljava/lang/String;)V
```

=> auto boxing в Java - зло. Программа, написанная с ними, не работает так, ты вы ожидаете, + высокая вероятность `NullPointerException`.

#### Инстанциация класса и инструкции методов

Основные директивы (call instuctions):

`invokestatic` - type safe вызов в JVM, который вызывает статический метод, при этом он не принимает объект, а принимает литерал класса (e.g. `HelloWorld.class`).

`invokespecial` - при обращении к родителю (`super.onResume()`).

`invokeinterface` - вызов интерфейсных методов.

`invokevirtual` - все методы по умолчанию виртуальные. Это вызов не статического метода, не интерфейсного, а метода класса.

`invokedynamic` - новая директива в Java 8. Для поддержки вызова лямбда-выражений.


## Коллекции в Java

Родительский интерфейс для интерфейса Collection?
* Интерфейс List
* Интерфейс BeanContext
* Интерфейс Iterable [правильно]
* Никакой, не наследуется от какого либо родительского интерфейса

![img alt](images/collections.png "")

### Интерфейс Iterable<E>
	
Основной способ использования `Iterable<E>` - вызов метода `iterator()`:
	
```java
void printAll(Iterable<?> iterable) {
  Iterator<?> iterator = iterable.iterator();
  while (iterator.hasNext()) {
    Object obj = iterator.next();
    System.out.println(obj);
  }
}
```

`Iterator` имеет 2 полезных метода -  

* `boolean hasNext()` 
* `next()`, возвращающий следующее значение и переходящий далее по коллекции.

Код выше эквивалентен for-циклу

```java
void printAll(Iterable<?> iterable) {
  for (Object obj : iterable) {
    System.out.println(obj);
  }
}
```

В нем итератора нет, но на самом деле он есть.

Итератор может использоваться для удаления элемента, для этого есть метод `remove()` - он может удалить последний полученный через `next()` элемент, а если `next()` ни разу не вызывался, то выбрасывается исключение `UnsupportedOperationException`:

```java
iterator.remove();
```

Если вызвать `iterable.iterator()` повторно, то можно обойти коллекцию заново (обычно реализовают так, но бывают исключения из правила, которые специально документируют этот момент).

`Iterable` может быть неизменяемым, `Iterator` – нет.

С Java 8 у `iterator.remove()` есть дефолтная реализация.

### Интерфейс Collection

* `int size();` - размер; может вернуть значение не более 2 млрд элементов (но это не значит, что вы не можете поместить в коллекцию больше)
* `boolean isEmpty();` - пустая ли коллекция
* `boolean contains(Object o);` - есть ли объект в коллекции (Заметьте, что принимает `Object`, а не обобщенный тип!)
* `Object[] toArray();`
* `<T> T[] toArray(T[] a);`
* `boolean add(E e);`
* `boolean remove(Object o);` - тоже объект
* `boolean containsAll(Collection<?> c);` - содержит ли все элементы указанной коллекции
* `boolean addAll(Collection<? extends E> c);`
* `boolean removeAll(Collection<?> c);`
* `boolean retainAll(Collection<?> c);` - сохраняет в коллекции только элементы из указанной коллекции
* `void clear();`

Модифицируемые и немодифицируемые коллекции в Java отличить нельзя (кроме как в рантайме попытаться модифицировать).

### Множество Set<E> extends Collection<E>
	
* Не содержит новых методов
* Содержит уточнённый контракт - коллекция уникальных элементов
* Не может содержать сам себя
* Сравним с любым другим Set по содержимому - см. метод `equals()`

### Список List<E> extends Collection<E>
	
Имеет много методов в дополнение к интерфейсу `Collection<E>`.
	
Если вы хотите удалить все элементы от некоторого индекса до другого индекса, то для этого удобно сделать `.sublist(200, 500);`, `.clear()`.

`ListIterator` - расширенный в обе стороны + задание и добавление элементов списка.

```java
class RangeList extends AbstractList<Integer> implements Set<Integer> {
  ...
}
```

В чем проблема этого кода? Невозможно одновременно выполнить контракт `List.hashCode()` и `Set.hashCode()`.

### Какие есть стандартные списки

* `ArrayList` – изменяемый список общего назначения
* Arrays.asList – изменяемая обёртка над массивом
* Collections.emptyList() – неизменяемый пустой список
* Collections.singletonList(x) – неизменяемый список из одного элемента
* Collections.nCopies(n, x) – неизменяемый список из n одинаковых элементов
* List.of(…) – (Java 9) неизменяемый список из указанных элементов (или массива), null не приемлет
* Collections.unmodifiableList(list) – неизменяемая обёртка над списком (не рекомендуется использовать)
* Collections.synchronizedList(list) – синхронизированная обёртка над списком (не рекомендуется использовать)
* Collections.checkedList(list, type) – проверяемая обёртка 

### Стандартные множества

* `HashSet` – изменяемое неупорядоченное множество общего назначения - самое основное. Никогда не закладывайтесь на порядок в `HashSet`е - на то, что вывод при итерации будет в определенном порядке. Не выводите пользователю Хэшсет в пользовательском интерфейсе.
* `LinkedHashSet` – изменяемое упорядоченное (ordered) множество общего назначения - нужен в случае, если нужно сохранить порядок, в котором вы добавляете элементы. Заметьте, что ordered != sorted, это разные вещи.
* `TreeSet` – изменяемое сортированное (sorted) множество
* `EnumSet` – изменяемое множество элементов enum
* `Collections.emptySet()` – неизменяемое пустое множество
* `Collections.singleton(x)` – неизменяемое множество из одного элемента
* `Set.of(...)` – неупорядоченное неизменяемое множество заданных элементов
(без null и повторов)
* `Collections.unmodifiableSet(set)` – неизменяемая обёртка над множеством
* `Collections.synchronizedSet(set)` – синхронизированная обёртка над множеством
* `Collections.checkedSet(set, type)` – проверяемая обёртка
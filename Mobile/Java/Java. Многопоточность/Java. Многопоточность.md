# Java. Многопоточность

__Доступ к разделяемому ресурсу__

* __Блокировка__ (mutex, mutual exclusion)
* __Неблокирующий доступ__:
 * __Lock-free__: гарантируется общий прогресс
 * __Wait-free__: гарантируется прогресс в каждом потоке исполнения
 
---
 
## Блокирующий доступ

* Для блокировки используется __монитор__ или __лок__
* Один и тот же ресурс должен блокироваться одним и тем же __монитором__.
* __*Блокировать надо как чтение, так и запись*__

### Ключевое слово synchronized

Для чего используется ключевое слово `synchronized`?

* Указывает на то, что этот метод класса синхронизирован.

Синхронизован может быть не только метод, но и блок кода внутри метода. Синтаксис при этом специфичный:

* `synchronized(obj) {…}`: монитор – объект `obj` (в Java можно синхронизоваться на любом объекте)
* `synchronized void method()`: монитор – объект `this`
* `synchronized static void method()`: монитор – объект `.class`

Не надо синхронизироваться по строке, Integer-объекту. Это может привести к тому, что один и тот же shared объект будет использоваться совершенно разными и не имеющими проблемы общей синхронизации частями программы. 

Стандартно используют `new Object()` в виде приватного поля. Это гарантирует, что никто другой не будет синхронизоваться по этому объекту.

__Пример__: потокобезопасное добавление в список

```java
public class Container {
    private static final List<String> list = new ArrayList<>();

    synchronized void addEntry(String s) {
        list.add(s);
    }
}
```

Здесь ошибка - доступ к __статическому__ объекту синхронизируется через экземпляр контейнера. Если экземпляров будет несколько, то возможны одновременные добавления, т.к. эти части кода будут независимыми и несинхронизованными.

Чтобы исправить ошибку, нужно, например, убрать слово `static`.

``` thread.join(); ``` выполняет ожидание до тех пор, пока тред не завершится.

---

### Java Memory Model

Memory Model (модель памяти) впервые появилась в Java. Потом другие поняли, что это важная вещь, и тоже стали делать у себя.

* Java Memory Model - это часть спецификации языка Java (JLS 17.4)
* Описывает __взаимодействие приложения с памятью__
* __Даёт определённые гарантии__ относительно того, какие записи в память когда и как могут быть видимы (эти места программист может пометить специальным образом в программе)
* __Не зависит от различий в реализации JVM, операционной системы и железа__

Понятия модели памяти:

__Атомарность__ (_atomicity_) - операция атомарна, если невозможно наблюдать (напр., из другого потока) частичный результат её выполнения. Любой наблюдатель видит либо состояние системы до атомарной операции, либо после.

В Java:
* Запись в поле типа boolean, byte, short, char, int, Object всегда атомарна
* Запись в поле типа long/double: атомарна запись старших и младших 32 бит
* Запись в поле типа long/double, объявленное volatile, атомарна

Также в Java есть классы `AtomicBoolean`, `AtomicInteger`, `Atomic*`, где реализована атомарность их значений.

Если для программиста атомарность поля типа double или long важна, то он может пометить его ключевым словом `volatile`.

__Арифметические операции неатомарны!__ Даже `x++`, `x *= 2;`.

```java
class Counter {
    int x = 0;
}
Counter c = new Counter();
Runnable r = () -> {
    for(int i=0; i<1000000; i++) c.x++;
};
List<Thread> threads = Stream.generate(() -> new Thread(r))
    .limit(10).peek(Thread::start)
    .collect(Collectors.toList());
for (Thread thread : threads) {
    thread.join();
}
System.out.println(c.x); // может выдать 2millions, 3millions, 10millions, 0.5millions.
```

### Ключевое слово volatile

Указывает на то, что поле синхронизировано для нескольких потоков, и каждый из них не будет создавать локальную копию, а будет работать с оригинальными данными.

---

С concurrency всё просто - 

* есть несколько атомарных типов - AtomicBoolean, AtomicInteger и др.

* unsafe, который гарантирует чтение между потоками.

# Kotlin

## Классы

Класс с главным конструктором (а остальные - вспомогательные):

```kotlin
class SqlQuery @ShouldNotBeOptimized constructor(sqlDialect: String)
```

Аннотация не обязательна, но может быть. Сокращенный синтаксис класса с конструктором

```kotlin
class SqlQuery(sqlDialect: String)  {
  val _sqlDialect = sqlDialect // объявление ПОЛЯ класса
}
```

То же самое в Котлине можно сделать короче:

```kotlin
class SqlQuery(val sqlDialect: String) // это неизменяемое поле, т.к. val (иначе - var)
```

### Свойства

```kotlin
class SqlDialect(val name: String) {
  val isDefault: Boolean // является ли этот диалект диалектом по умолчанию
    get() {
      return "" == name
    }
}
```

(можно вспомнить С#).

Объекты классов создаются без `new`.

По умолчанию в Котлине всё публичное (а не пакетное как в Java).

То же свойство через functional expression:

```kotlin
class SqlDialect(val name: String) {
  val isDefault: Boolean
    get() = "" == name
}
```

здесь в действительности не хранится никакое поле. Случай, когда есть backing field:

```kotlin
class SqlConfig {
  var hasCaching = false
    get() {
      println(”Getting hasCaching: $field”) // так можно получить бэкинг филд
      return field // так можно получить бэкинг филд
    }
    set(value) {
      if (value == field) return
      println(”Setting hasCaching: $field”)
      if (value) {
        // Do some caching stuff
      } else {
        // Do some non-caching stuff
      }
      field = value
    }
}
```

### Инициализация класса  [23:00]

Если есть какая-то нетривиальная инициализация полей класса


# Kotlin

## Классы

### POJO/EJB в Котлине

В Java

```java
public class MyPOJO {
  private String value;

  public String getValue() {
    return value;
  }

  public void setValue(final String value) {
    this.value = value;
  }
  
  @Override
  public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass())
      return false;
    
	final MyPOJO myPOJO = (MyPOJO) o;
    
	return value != null
      ? value.equals(myPOJO.value)
      : myPOJO.value == null;
  }
  
  @Override
  public int hashCode() {
    return value != null ? value.hashCode() : 0;
  }
  
  @Override
  public String toString() {
    return ”MyPOJO{” + '\'' + value + '\'' + '}';
  }
}
```

И это всего лишь класс, содержащий одно строковое поле. [Вот тут лектор не прав - это не поджо, а Java Bean]

Котлин

```kotlin
class MyPOKO(var value: String) {
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || javaClass != other.javaClass)
      return false

    val myPOKO = other as MyPOKO
  
    return value == myPOKO.value
  }

  override fun hashCode(): Int = value.hashCode()

  override fun toString(): String = ”MyPOKO{'$value'}”
}
```

Еще короче и проще - сделать __data class__:

```kotlin
data class MyPOKO(var value: String)
```

Делает за вас
* геттеры/сеттеры (они и так есть в Котлине)
* Генерирует `equals()/hashCode()`
* `toString()`
* `componentN()` (??)
* `copy()` - метод копирования data class'a

Но у Data Class есть ограничения:

* От него нельзя наследоваться (no open)
* Поэтому он не может быть абстрактным (no abstract)
* Он не может иметь внешний контекст (no inner, но может быть статическим вложенным)
* Он также не может быть запечатанным (no sealed) 
* Должен быть хотя бы один параметр у главного конструктора
* Все параметры конструктора должны быть полями класса

Теперь начнем писать что-то типа "Retrofit":

```kotlin
interface Jsonable {
  fun toJson() : JsonValue = TODO() // следует сделать реализацию по умолчанию
}

data class SignUpMsg(var denizenId: String, var password: String, var email: String?) : Jsonable

data class LoginMsg(var denizenId: String, var password: String) : Jsonable

data class InfoMsg(var denizenId: String) : Jsonable
```

Если в интерфейсе есть реализация одного из сгенерированных методов, то можно сделать так:

```kotlin
data class My(var num: Int) : Formattable {
	
  override fun toString() = super.toString()
}
```

Реализованные вами самими функции не будут перегенерироваться компилятором.

Синглетонов объектов `data object` в Котлине НЕТ.

### Деструктивное объявление

```kotlin
fun processSignUpMsg(msg: SignUpMsg) {
    val (id, pwd, email) = msg
    // ...
}
```

* Использует методы componentN класса (если они у него есть) для того, чтобы “разобрать” объект на составные части
* Если “разобрать” не получается, компилятор выдаст ошибку

Для объекта `SignUpMsg` будут сгенерированы методы `component1(), component2(), component3()`. Соответственно возвращаемые ими значения присваиваются в `id, pwd, email`. -> Не надо писать три строчки с присваиваниями, это очень приятно.

Можно также

```kotlin
for((k, v) in map) {
    ...
}
```

Если какие-то позиции в destructive declaration вас не интересуют, то можно просто заменить их на подчеркивание

```kotlin
fun fixSignUpMsg(msg: SignUpMsg): SignUpMsg {
    val (_, password) = msg
    val pwdHash = computePwdHash(password)

    return SignUpMsg(
        msg.denizenId,
        pwdHash,
        msg.email
    )
}
```

Переменной с именем `_` не появляется.

Другой способ копирования - 

```kotlin
fun fixSignUpMsg(msg: SignUpMsg): SignUpMsg = msg.copy(
    password = computePwdHash(msg.password)
)
```

Но что здесь происходит - не очень понятно. Тут есть 2 новых понятия - первое это __именованные аргументы__.

### Именованные аргументы

Котлин поддерживает именованные аргументы
* При вызове функции можно указать аргумент в виде `имя = значение`
* В качестве имени используется имя переменной, являющейся формальным аргументом функции…

```kotlin
fun createConfig(sqlDialect: String, acidLevel: AcidLevel, dbPath: Path, threadPoolSize: Int) 
    : Config = TODO()
```
	
Чтобы не указывать все значения, Котлин поддерживает аргументы по умолчанию

```kotlin
fun createConfig(
    sqlDialect: String = ”PostgreSQL”,
    acidLevel: AcidLevel = AcidLevel.READ_COMMITED,
    dbPath: Path,
    threadPoolSize: Int = 1
) : Config = TODO()

val DEFAULT_CONFIG = createConfig(Paths.get(”/home/me”, ”db.file”)) // Error!!
```

Позиционные и именованные аргументы не смешиваются просто так, если вы хотите еще и воспользоваться значениями по умолчанию
* Выход: сделать позиционный аргумент именованным

А что с наследованием этого дела?

* Аргументы по умолчанию не наследуются
 * Более того, они в принципе допускаются только в непереопределенных методах. Потому что override - это механизм времени выполнения, а умолчательные значения определяются при компиляции. Мы не можем заранее знать из-за полиморфизма, какие в общем случае нам понадобятся значения по умолчанию -- они могли бы быть любыми.

* Именованные аргументы не наследуются

__Пример__ на "подумать":

```kotlin
open class A {
    open fun foo(a: Int = 1, b: Int = 2): String = ”$a$b”
}

class B : A() {
    override fun foo(b: Int, a: Int): String = super.foo(a, b)
}

fun main(args: Array<String>) {
    val a: A = B()
    println(a.foo(a = 1)) // что здесь будет??
}
```

### Перечисления (продолжение)

Для перечислений можно заводить поля / свойства, методы

```kotlin
enum class HttpCode(val code: Int)
    /* : Comparable<HttpCode> */ {
    OK(200),
    BAD_REQUEST(400),
    FORBIDDEN(403),
    IM_A_TEAPOT(418) {
        override fun isOfficial() = false
		
		// Здесь можно определить вообще отдельные методы только для данного чайника
    },
    INTERNAL_SERVER_ERROR(500);
	
	open fun isOfficial() = true
}
```

И перечисления неявно являются Comparable.

Перечисления удобны в `when`.

```kotlin
// 1. Строковое представление значение в enum (напр., "BAD_REQUEST" etc)
fun httpCodeToHttpMessage(code: HttpCode): String = code.name

// 2. порядковый номер с нуля
fun httpCodeToInternalCode(code: HttpCode): Int = code.ordinal

// 3. Enum объект из строки:
fun httpMessageToHttpCode(msg: String): HttpCode =
    HttpCode.valueOf(msg) // IllegalArgumentException при неправильной строке

// 4. Массив всех Enum: HttpCode.values()
fun internalCodeToHttpCode(code: Int): HttpCode =
    HttpCode.values()[code]
```

В остальном Enum такие как в Java.



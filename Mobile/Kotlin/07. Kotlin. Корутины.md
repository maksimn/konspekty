# Kotlin

## Корутины

### Простая асинхронная задача из 3 шагов

```kotlin
fun postItem(item: Item) {
    val token = requestToken()
    val post = createPost(token, item)
    processPost(post)
}
```

### Callbacks

```kotlin
fun requestTokenAsync(cb: (Token) -> Unit) {
    // делает запрос токена, вызывает коллбэк по итогу этого запроса
	// возвращает управление немедленно
}
```

Функция делает возврат сразу, а её коллбэк вызывается когда-нибудь потом. 

Код из цепочки вызовов таких функций - ужасен.

### Futures/Promises/Rx

```kotlin
fun requestTokenAsync(): Promise<Token> {
    // делает запрос токена, вызывает коллбэк по итогу этого запроса
	// возвращает обещание будущего результата немедленно
}
```

В итоге нужный код выглядит так

```kotlin
fun postItem(item: Item) {
    requestTokenAsync()
	    .thenCompose { token -> createPostAsync(token, item) }
		.thenAccept { post -> processPost(post) }
}
```

Здесь обработка ошибок гораздо лучше, чем в коллбэках. Если операция получения токена сломается, то код пойдет в обработку ошибок и не будет делать следующие шаги.

Но тут есть проблема комбинаторов - надо знать thenCompose, thenAccept, обработку ошибок, комбинатор для циклов и т.д. Для каждой библиотеки.

### Корутины

Это функция с естественной сигнатурой и модификатором suspend:

```kotlin
suspend fun requestToken(): Token {
    // делает запрос токена и приостанавливает своё выполнение
	// ...
	return token // возвращает токен после его получения
}
```

В итоге код с корутинами выглядит так:

```kotlin
suspend fun postItem(item: Item) {
    val token = requestToken() // async 
    val post = createPost(token, item) // async
    processPost(post) // sync
}
```

Заметим, что асинхронный и синхронный вызовы не отличаются по внешнему виду. Здесь спасает IDE - помогает отличить один от другого.

Циклы при этом выглядят естественно:

```kotlin
for((token, item) in list) {
    createPost(token, item)
}
```

А на CompletableFuture это бы выглядело куда хуже.

Обработка ошибок - тоже как обычно

```kotlin
try {
    createPost(token, item)
} catch(e: BadTokenException) {
    // ...
}
```

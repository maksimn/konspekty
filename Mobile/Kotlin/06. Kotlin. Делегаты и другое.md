# Kotlin

## Делегаты

### Delegation pattern

* Альтернатива наследованию
* Частный случай композиции
* Вместо реализации методов вы делегируете их реализацию другому объекту

```kotlin
class FlexibleSet<T>(private val threshold: Int = 4) : MutableSet<T> {
    private var innerSet: MutableSet<T> = COWArraySet<T>()
    // ...
}
```

```kotlin
private inline fun <R> flex(body: () -> R): R {
    val res = body()
    when {
        innerSet is HashSet && innerSet.size < threshold -> {
            val oldSet = innerSet
            innerSet = COWArraySet()
            innerSet.addAll(oldSet)
        }
        // ...
    }
    return res
}
```

```kotlin
class FlexibleSet<T>(private val threshold: Int = 4) : MutableSet<T> {
    override fun add(element: T): Boolean =
        flex { innerSet.add(element) }

    override fun addAll(elements: Collection<T>): Boolean =
        flex { innerSet.addAll(elements) }

    override fun clear() = flex { innerSet.clear() }
}
```

```kotlin
class FlexibleSet<T>(private val threshold: Int = 4) : MutableSet<T> {
    override val size: Int
    
	get() = innerSet.size

    override fun contains(element: T): Boolean =
        innerSet.contains(element)

    override fun containsAll(elements: Collection<T>): Boolean =
        innerSet.containsAll(elements)
}
```

Хочется писать меньше кода.

### Делегирование

```kotlin
class BetterFlexibleSet<T>(private val threshold: Int = 4,
    private var innerSet: MutableSet<T> = COWArraySet<T>()) : MutableSet<T> by innerSet {
    // ...
}
```

* Все неперегруженные вызовы будут делегироваться полю innerSet
* Перегруженные вызовы будут работать в соответствии с реализацией

```kotlin
data class MutableFileTree(private val data: MutableMap<String, MutableFileTree> = mutableMapOf(),
    var changed: Boolean = false) : MutableMap<String, MutableFileTree> {
    // Here be a looot of delegation...
}
```

```kotlin
data class MutableFileTree(private val data: MutableMap<String, MutableFileTree> = mutableMapOf(),
    var changed: Boolean = false) : MutableMap<String, MutableFileTree> by data
```

### Delegated properties

А если я хочу отделегировать, но не всю реализацию интерфейса, а один метод? Тогда его проще взять и реализовать. 

А если не метод, а свойство?

```kotlin
class Config(val data: MutableMap<String, Any?>) {
    var Url: String
	
    get() = data[”Url”] as String

    set(value) {
        data[”Url”] = value
    }
}
```

```kotlin
class BetterConfig(val data: MutableMap<String, Any?>) {
    var Url: String by data // wat?
}
```

```kotlin
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        // get the actual value you want
    }
	
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        // set the actual value you want
    }
}
```

```kotlin
public inline operator fun <V, V1 : V> MutableMap<in String, out V>.getValue(thisRef: Any?, 
	property: KProperty<*>): V1 = getOrImplicitDefault(property.name) as V1

public inline operator fun <V> MutableMap<in String, in V>.setValue(thisRef: Any?, 
	property: KProperty<*>, value: V) {
    put(property.name, value)
}
```

Делегирующие функции могут быть функциями-расширениями.

### Stdlib delegates

```kotlin
lazy { … }

class BetterConfig(val data: MutableMap<String, Any?>) {
    val secretKey: String by lazy {
        loadSecretKeyFromSecretStorage()
    }
}
```

Можно использовать из нескольких потоков. При необходимости можно ослабить уровень синхронизации.

```kotlin
observable(defaultValue) { prop, old, new -> … }

class BetterConfig(val data: MutableMap<String, Any?>) {
    var ThreadCount: Int
    by observable(data[”ThreadCount”] as Int) {
        _, old, new ->
       println(”Changing thread count from $old to $new”)
    }
}
```

```kotlin
vetoable(defaultValue) { prop, old, new -> … }

class BetterConfig(val data: MutableMap<String, Any?>) {
    var ThreadCount: Int
    by vetoable(data[”ThreadCount”] as Int) {
        _, old, new -> new <= 24
    }
}
```

### Local delegated properties

```kotlin
fun handleHttpRequest(req: HttpRequest): HttpResponse {
    val userId by req
    val userData by req
}

operator fun HttpRequest.getValue(thisRef: Nothing?, prop: KProperty<*>): String? =
    this.getParam(prop.name)
```

### Providing delegated property

```kotlin
fun handleHttpRequest(req: HttpRequest): HttpResponse {
    val userId by req
    val userData by req
    val smthImpossible by req
}
```

А если я хочу проверять допустимость делегата при создании?

```kotlin
operator fun HttpRequest.provideDelegate(thisRef: Nothing?, prop: KProperty<*>):   
    ReadOnlyProperty<Nothing?, String?> {
    if (prop.name !in RestApi.allowedUrlParams)
        throw IncorrectUrlParamException(prop.name)

    return object : ReadOnlyProperty<Nothing?, String?> {
        override fun getValue(/*...*/): String? {
            return this@provideDelegate.getParam(prop.name)
        }
    }
}
```

---

### Standard library overview

Сборка кода на Котлине, варианты:

* IntelliJ IDEA
* Ant
* Maven
* Gradle

Детали настройки — см. в соответствующей инструкции.

Из интересных возможностей
* Инкрементальная компиляция
* Задание целевой версии JVM (1.6 или 1.8)
* Расширенная версия стандартной библиотеки (поддержка Java 1.7/1.8)
* Поддержка обработки аннотаций через kapt (JSR 269)

### Kotlin -> Java interop

А если я использую библиотеки, которые ожидают Java, а получают Котлин? Тогда что-то не соберется, или вообще ничего не соберется.

Надо поменять поведение. Плагины компилятора.

__Java Persistence API__

Ожидает, что у всех классов будет конструктор по умолчанию без параметров

data class нарушает это ожидание

`kotlin-noarg/kotlin-jpa` плагин компилятора
* Генерирует синтетические конструкторы без параметров
* Нельзя вызвать из кода, можно через рефлексию

__Spring framework__

Ожидает, что от классов можно наследоваться, а в Котлине все final по умолчанию

`kotlin-allopen/kotlin-spring` плагин компилятора. Делает требуемые классы open.

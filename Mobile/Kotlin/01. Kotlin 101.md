# Kotlin

Плюсы Котлина, особенно в сравнении с Java:

* Есть функции высших порядков
* Вывод типов
* String interpolation
* Удобное создание встроенных DSL
* Отказ от проверяемых исключений
* Можно писать код, который никогда не бросает `NullPointerException`

Проблемы Котлина

* Отсутствие спецификации
 * Наличие эталонной реализации (имеет баги, изменяется со временем)
 
## Hello World (Kotlin)

```kotlin
fun main(args: Array<String>) {
    println(”Hello, World!”)
}
```

Классы в Котлине необязательны, можно работать с функциями без определения классов.

```kotlin
fun main(args: Array<String>) {
    require(args.size > 0) // стд функция, кидает IllegalArgumentException при невыполнении условия
    val firstName: String = args[0] // val -  неизменяемая переменная
	              //  тип можно не писать, так как в Котлине есть вывод типов
    var lastName = args[args.lastIndex] // var - изменяемая переменная
    lastName = ”Not Akhin”
    println(”Hello, $firstName $lastName”) // интерполяция строк
}
```

Вынесем функциональность в отдельные функции:

```kotlin
fun getFirstName(names: Array<String>): String? { // Т? означает либо значение типа T(), либо null
    if (names.size > 0) return names[0]
    else return null
}

fun getLastName(names: Array<String>): String? {
    if (names.size > 1) return names[names.lastIndex]
    else return null
}
```

Если использовать только тип без вопросика, то такой код никогда не породит `NullPointerException` - так решена проблема этого исключения.

If в Котлине является не statement, а expression - он может возвращать значение:

```kotlin
fun getFirstName(names: Array<String>): String? {
    return if (names.size > 0) names[0]
        else null
}
fun getLastName(names: Array<String>): String? {
    return if (names.size > 1) names[names.lastIndex]
        else null
}
```

Поэтому в Котлине можно, объявляя переменную, сразу присвоить ее в зависимости от условия, а не позже ссылаться на нее и присваивать в идущих далее блоках.

return можно вообще выкинуть в данном случае:

```kotlin
fun getFirstName(names: Array<String>) =
    if (names.size > 0) names[0]
    else null

fun getLastName(names: Array<String>) =
    if (names.size > 1) names[names.lastIndex]
    else null
```

И без типа возвращаемого функцией значения - он тоже выводится автоматически. Если определить функцию с блоком из фигурных скобок - то возвращаемый тип нужно писать практически всегда, кроме случая возврата void.


Теперь функция main() может быть, например, такой

```kotlin
fun main(args: Array<String>) {
    val firstName = getFirstName(args) ?: "John"
    val lastName = getLastName(args) ?: "Doe"
    println(”Hello, $firstName $lastName”)
}
```

?: - это __элвис-оператор__ (это то же самое, что оператор ?? в C#, насколько я его помню).

Ещё 2 оператора, связанных с nullability:

```kotlin
fun shorten(name: String?): String {
    if (true == name?.isNotEmpty()) { // В Котлине нельзя вызвать метод nullable типа через просто точку
        return name!!.get(0) + ”.” 
    } else {
        return ””
    }
}
```

`a?.foo()` - safe call operator. При `a == null` вернет null. => Удобные цепочки вызовов.

`!!.` - оператор "давай бахнем!!" - работает с типом T? как с просто T, но в случае null кидает `NRE`. Применяется редко. В данном примере его применение абсолютно безопасно, так как выполняется if-условие.

```kotlin
null == true // false
null == false // false
```